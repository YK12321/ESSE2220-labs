import RPi.GPIO as GPIO
import time

LSBFIRST = 1
MSBFIRST = 2

# Define the pins connected to 74HC595 shift registers
dataPin   = 11      # DS Pin of 74HC595(Pin14) - Serial data input
latchPin  = 13      # ST_CP Pin of 74HC595(Pin12) - Storage register clock
clockPin = 15       # SH_CP Pin of 74HC595(Pin11) - Shift register clock

def reverseBits(byte):
    """Reverse the bits in a byte (mirror horizontally).
    This corrects horizontal flipping in the LED display."""
    result = 0
    for i in range(8):
        if byte & (1 << i):
            result |= (1 << (7 - i))
    return result

def mirrorHorizontal(pattern):
    """Mirror a pattern horizontally by reversing bits in each row."""
    return [reverseBits(byte) for byte in pattern]

def rotateLeft90(pattern):
    """Rotate pattern 90 degrees counter-clockwise (left).
    This corrects the orientation mismatch between OpenCV and LED display."""
    # Convert bytes to 8x8 bit array
    bits = []
    for byte in pattern:
        row = [(byte >> (7-i)) & 1 for i in range(8)]
        bits.append(row)
    
    # Rotate: new[row][col] = old[col][7-row]
    rotated = [[bits[col][7-row] for col in range(8)] for row in range(8)]
    
    # Convert back to bytes
    result = []
    for row in rotated:
        byte = 0
        for i, bit in enumerate(row):
            byte |= (bit << (7-i))
        result.append(byte)
    return result

# Image data from imageHexData.dat (raw values generated by processImage.py)
binarypic_raw = [241, 130, 132, 136, 240, 240, 240, 240]
sobelpic_raw = [96, 255, 127, 255, 255, 255, 255, 126]
cannypic_raw = [105, 81, 139, 80, 100, 73, 136, 41]

# Fix orientation: mirror horizontally then rotate left 90 degrees
# This ensures the LED display matches the OpenCV image orientation
binarypic = rotateLeft90(mirrorHorizontal(binarypic_raw))
sobelpic = rotateLeft90(mirrorHorizontal(sobelpic_raw))
cannypic = rotateLeft90(mirrorHorizontal(cannypic_raw))

# Letter patterns for labeling (B=Binary, S=Sobel, C=Canny)
letter_B = [0x00, 0x00, 0x7F, 0x49, 0x49, 0x36, 0x00, 0x00]  # "B"
letter_S_raw = [0x00, 0x00, 0x46, 0x49, 0x49, 0x31, 0x00, 0x00]  # "S" (raw)
letter_S = mirrorHorizontal(letter_S_raw)  # Fix horizontal mirror for "S"
letter_C = [0x00, 0x00, 0x3E, 0x41, 0x41, 0x22, 0x00, 0x00]  # "C"
blank = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]     # Blank screen

# Dictionary mapping labels to their display data
data = {
    'B': letter_B,
    'binarypic': binarypic,
    'S': letter_S,
    'sobelpic': sobelpic,
    'C': letter_C,
    'cannypic': cannypic,
    'blank': blank
}

def setup():
    """Initialize GPIO pins for controlling the 74HC595 shift registers."""
    GPIO.setmode(GPIO.BOARD)    # Use physical pin numbering
    GPIO.setup(dataPin, GPIO.OUT)
    GPIO.setup(latchPin, GPIO.OUT)
    GPIO.setup(clockPin, GPIO.OUT)

def shiftOut(dPin, cPin, order, val):
    """Shift out a byte of data to the 74HC595 shift register.
    
    Args:
        dPin: Data pin (serial data input)
        cPin: Clock pin (shift register clock)
        order: LSBFIRST or MSBFIRST (bit order)
        val: 8-bit value to shift out
    """
    for i in range(0, 8):
        GPIO.output(cPin, GPIO.LOW)
        if(order == LSBFIRST):
            # Shift out LSB first
            GPIO.output(dPin, (0x01 & (val >> i) == 0x01) and GPIO.HIGH or GPIO.LOW)
        elif(order == MSBFIRST):
            # Shift out MSB first
            GPIO.output(dPin, (0x80 & (val << i) == 0x80) and GPIO.HIGH or GPIO.LOW)
        GPIO.output(cPin, GPIO.HIGH)

def displayPattern(pattern, duration):
    """Display a pattern on the LED matrix for the specified duration.
    
    Uses multiplexing to rapidly scan through rows, creating the illusion
    of all rows being lit simultaneously.
    
    Args:
        pattern: List of 8 bytes, each representing one row of the 8x8 matrix
        duration: Time in seconds to display the pattern
    """
    start_time = time.time()
    while time.time() - start_time < duration:
        x = 0x80  # Start with first row (binary 10000000)
        for i in range(0, 8):
            # Latch low to prepare for data transfer
            GPIO.output(latchPin, GPIO.LOW)
            # Shift out column data (which LEDs in this row should be on)
            shiftOut(dataPin, clockPin, MSBFIRST, pattern[i])
            # Shift out row selector (which row to activate)
            shiftOut(dataPin, clockPin, MSBFIRST, ~x)  # Inverted for common cathode
            # Latch high to display the data
            GPIO.output(latchPin, GPIO.HIGH)
            # Brief delay for multiplexing (persistence of vision)
            time.sleep(0.001)
            x >>= 1  # Move to next row

def loop():
    """Main display loop: cycles through all three edge detection methods.
    
    Sequence:
    - B (2s) → Binary Original (10s) → Blank (0.5s)
    - S (2s) → Sobel Edges (10s) → Blank (0.5s)
    - C (2s) → Canny Edges (10s) → Blank (0.5s)
    """
    while True:
        # Display Binary Original
        displayPattern(data['B'], 2)
        displayPattern(data['binarypic'], 10)
        displayPattern(data['blank'], 0.5)
        
        # Display Sobel Edge Detection
        displayPattern(data['S'], 2)
        displayPattern(data['sobelpic'], 10)
        displayPattern(data['blank'], 0.5)
        
        # Display Canny Edge Detection
        displayPattern(data['C'], 2)
        displayPattern(data['cannypic'], 10)
        displayPattern(data['blank'], 0.5)

def destroy():
    """Clean up GPIO resources before exiting."""
    GPIO.cleanup()

if __name__ == '__main__':
    print('Program is starting...')
    setup()
    try:
        loop()
    except KeyboardInterrupt:
        destroy()